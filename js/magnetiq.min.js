/*!
CANVAS CONSTELLATION				 FIRST VERSION
--------------------------------------------------
Okay, this is an experimental constellation of ci-
rcles made in Canvas, HTML5 and Javascript.

Every stuff you see in here is property and produ-
ction of Alessio Santo, all rights reserved.

Don't touch anything down here please.
---------------------------------------------------
THE CODE STARTS HERE
 */
window.requestAnimFrame = (function(){
	return  window.requestAnimationFrame       || 
        window.webkitRequestAnimationFrame || 
        window.mozRequestAnimationFrame    || 
        window.oRequestAnimationFrame      || 
        window.msRequestAnimationFrame     || 
        function(/* function */ callback, /* DOMElement */ element){
        	window.setTimeout(callback, 1000 / 60);
        };
	})();



/*
 --------------------------------------------------
 CREATING AN OBJECT:						  POINT
 -------------------------------------------------- */



function Point(properties){

	if(properties.x === undefined){
		properties.x = 0;
	}
	if(properties.y === undefined){
		properties.y = 0;
	}
	if(properties.radius === undefined){
		properties.radius = 5;
	}
	if(properties.velocity === undefined){
		properties.velocity = 30;
	}
	if(properties.aggregation === undefined){
		properties.aggregation = null;
	}
	if(properties.distance === undefined){
		properties.distance = 50;
	}
	var self			= this;

	self.position    	= {
							x: properties.x,
							y: properties.y
						};						
	self.radius 		= properties.radius;
	self.velocity 		= properties.velocity;
	self.aggregation 	= properties.aggregation;
	self.distance	 	= properties.distance;
	
	
	self.setRadius 	=	function(raggio){
		self.radius=raggio;
	};

	self.setPosition 	=	function(x,y){
		self.position.x = x;
		self.position.y = y;
	};
	var internal = 0;
	self.muoviti = function(){
		internal++;
    	var time = internal * 0.002 * self.velocity;
    	var center = {  x: self.aggregation.position.x, 
    					y: self.aggregation.position.y };
		self.position.x = self.distance * Math.cos(time) + center.x;
		self.position.y = self.distance * Math.sin(time) + center.y;
		
		requestAnimFrame(self.muoviti);

	};
	
}
 
 
/* --------------------------------------------------
 CREATING AN OBJECT:						MESSAGE
 -------------------------------------------------- */
 
function Galaxy(properties){
	

}
 
var CanvasImage = {
	src: "",
	x: 0,
	y: 0
};
 /*
 --------------------------------------------------
 CREATING AN OBJECT:					  AGGREGATION
 -------------------------------------------------- */
function Aggregation(properties){

	if(properties.x === undefined){
		properties.x = 0;
	}
	if(properties.y === undefined){
		properties.y = 0;
	}
	if(properties.radius === undefined){
		properties.radius = 100;
	}
	if(properties.velocity === undefined){
		properties.velocity = 30;
	}
	if(properties.distance === undefined){
		properties.distance = 30;
	}
	if(properties.aggregation === undefined){
		properties.aggregation = null;
	}
	
	var self			= this;

	self.position    	= {
							x: properties.x,
							y: properties.y
						};						
	self.radius 		= properties.radius;
	self.distance 		= properties.distance;
	self.velocity 		= properties.velocity;
	self.aggregation 	= properties.aggregation;
	self.pointer	 	= properties.pointer;
	
	var internal = Math.random()*100000;
	self.muoviti = function(){
		internal++;
    	var time = internal * 0.002 * self.velocity;
    	var center = {  x: self.aggregation.position.x, 
    					y: self.aggregation.position.y };
		self.position.x = self.distance * Math.cos(time) + center.x;
		self.position.y = self.distance * Math.sin(time) + center.y;
		
		requestAnimFrame(self.muoviti);

	};
	
	var internal_2 = 0;
	self.reachThePointer = function(){
		var head = self.pointer.passages[self.pointer.passages.length - 1];
		var x = 0,y = 0;
		var dX = Math.abs(self.position.x - head.position.x);
		var dY = Math.abs(self.position.y - head.position.y);
		
		var coeffX = dX / 2000;
		var coeffY= dY / 2000;
		
		if(self.position.x < head.position.x){
			x = coeffX;
		}else{
			x = -coeffX;
		}
		
		if(self.position.y < head.position.y){
			y = coeffY;
		}else{
			y = -coeffY;
		}
		
		self.position.x += x;
		self.position.y += y;
		
		requestAnimFrame(self.reachThePointer);
	};

}

function Track(q,device){

	function Passage(x,y){
		this.position = {
			x: x,
			y: y
		};
	}

	var self = this;
	var lifes = 3;
	self.collided = false;
	self.passages = [];
	
	for(var i = 0; i < 50; i++){
		self.passages.push(new Passage(q.width + 50, q.height +  50));
	}

	self.initialize = function(){
		
		if(device == "desktop"){
			q.addEventListener("mousemove",function(e){
				e.preventDefault();
				self.passages[self.passages.length - 1].position = {x: e.clientX, y: e.clientY};
			});
		
			q.addEventListener("mouseover",function(e){
				e.preventDefault();
				console.log(e);
				self.passages = [];
				for(var i = 0; i < 50; i++){
						self.passages.push(new Passage(e.clientX,e.clientY));
				}
			});
		}

		if(device == "mobile"){
			q.addEventListener("touchmove",function(e){
				e.preventDefault();
				var touch = e.touches[0];
				self.passages[self.passages.length - 1].position = {x: touch.pageX, y: touch.pageY};
			});
		
			q.addEventListener("touchstart",function(e){
				e.preventDefault();
				//self.passages = [];
				/*for(var i = 0; i < 50; i++){
						self.passages.push(new Passage(e.pageX,e.pageY));
				}*/
			});
		}
		
		self.hit = function(){
			self.collided = true;
			window.setTimeout(function(){
				self.collided = false;
			}, 1000);
			lifes --;
		};
		self.upLife = function(){
			self.lifes ++;
		};
		
		update();
		function update(){
			requestAnimFrame(update);
			for(var i = 0; i < self.passages.length - 1; i++){
				if(true){
					self.passages[i].position.y = self.passages[i + 1].position.y;
					self.passages[i].position.x = self.passages[i + 1].position.x;
				}
			}

		}
		
	};
	self.getLife = function(){
		return lifes;
	};

	
}


var isMobile = {
    Android: function() {
        return navigator.userAgent.match(/Android/i);
    },
    BlackBerry: function() {
        return navigator.userAgent.match(/BlackBerry/i);
    },
    iOS: function() {
        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
    },
    Opera: function() {
        return navigator.userAgent.match(/Opera Mini/i);
    },
    Windows: function() {
        return navigator.userAgent.match(/IEMobile/i);
    },
    any: function() {
        return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
    }
};


function MagnetiqWorld(){
	
//	CONTROL VARIABLES
	var start 	= document.getElementById("start-game");
	var status 	= document.getElementById("game-status");
	
	var self = this;
	var gameStatus = "pause";

	
	
	self.galaxy		= [];
	self.aggregations 	= [];
	self.initialize = function(){
		
		var canvas = document.getElementById("magnetiq");
		var device = "desktop";
		if( isMobile.any() ) device = ('mobile');

		self.pointer = new Track(canvas, device);
		
		self.draw = function(){
			requestAnimFrame(self.draw);
			drawCanvas();
		};
		
		collisions(self.pointer);
		
		function collisions(pointer){
			requestAnimFrame(function(){
				collisions(self.pointer);
			});
			if(gameStatus == "running"){
				var head = pointer.passages[pointer.passages.length - 1];
				for(var i in self.galaxy){
					var obj = self.galaxy[i];
					var collision = Math.sqrt( Math.pow(head.position.x - obj.position.x , 2) + Math.pow(head.position.y - obj.position.y , 2) );
					
					if(collision <= obj.radius +3){
						pointer.hit();
						delete self.galaxy[i];
					}
				}
			}
		}
		
		function drawCanvas() {
			canvas.width = canvas.width;
			if(canvas.getContext){
			
				
				var ctx = canvas.getContext("2d");
				var pointer_color = "#B9D639";
				if(self.pointer.collided) pointer_color = "red";
				
				ctx.fillStyle = pointer_color;
				ctx.strokeStyle = pointer_color;
				ctx.lineWidth = 2;
				
				
				ctx.beginPath();

				for(var i in  self.pointer.passages){
					var normal = self.pointer.passages[i]; 
					
					if(i == 0){
					 	ctx.moveTo(normal.position.x , normal.position.y);
					}else{
						var previous = self.pointer.passages[i-1];
					
						ctx.quadraticCurveTo(previous.position.x , 
								previous.position.y , 
								previous.position.x + (normal.position.x - previous.position.x) / 2 , 
								previous.position.y + (normal.position.y - previous.position.y) / 2);
					}			
				}
				ctx.stroke();
				ctx.closePath();
				
				for(var i = 0; i < self.pointer.getLife() - 1; i++){
					ctx.beginPath();
					var length = self.pointer.passages.length;
					var passage = self.pointer.passages[i * 8];
					ctx.arc(passage.position.x, passage.position.y, 4, 0, Math.PI * 2, false);
					ctx.fill();
				}
				
				ctx.beginPath();
				var head = self.pointer.passages[self.pointer.passages.length - 1];
				ctx.arc(head.position.x, head.position.y, 6, 0, Math.PI * 2, false);
				ctx.fill();

				
				for(var i in self.aggregations){
					var obj = self.aggregations[i];
					ctx.beginPath();
					ctx.fillStyle = "#57d0f3";
					ctx.arc(obj.position.x, obj.position.y, 10, 0, Math.PI * 2, false);
					ctx.fill();
				}
	
				for(var i in self.galaxy){
					var obj = self.galaxy[i];
					ctx.beginPath();
					ctx.fillStyle = "red";
					ctx.arc(obj.position.x, obj.position.y, obj.radius, 0, Math.PI * 2, false);
					ctx.fill();

				}
	
			}
		}
		
		
		self.addPoint = function(properties){
			var distance = 1000000;
			var closest;
			var proto = properties;
			for(var i in self.aggregations){
				var obj = self.aggregations[i];
				var tmp_distance = Math.sqrt( Math.pow(proto.x - obj.x , 2) + Math.pow(proto.y - obj.y , 2) );
				if(tmp_distance < distance){
					closest = obj;
					distance = tmp_distance;
				}
			}
			properties.aggregation = obj;
			self.galaxy.push(new Point(properties));
			self.galaxy[self.galaxy.length-1].muoviti();
		};
		
		

	};
	
	self.pauseMenu = function(){
		self.aggregations.push(new Aggregation({
			x: 100, 
			y: 100,
			pointer: self.pointer
		}));
		self.aggregations[0].reachThePointer
		for(var i = 0; i < 100; i++){
			
			var verse = Math.random()*2;
			var velocity = 5 + Math.random()*5;
			var distance = 50 + Math.random()*400;
			self.addPoint({
				x: -100, y: -100,
				velocity: velocity,
				distance: distance
			});
		}
	};
	self.pauseMenu();

}

